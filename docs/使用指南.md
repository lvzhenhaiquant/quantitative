# 量化回测系统使用指南

## 目录

- [1. 系统概述](#1-系统概述)
- [2. 快速开始](#2-快速开始)
- [3. 因子计算](#3-因子计算)
- [4. 回测运行](#4-回测运行)
- [5. API 参考](#5-api-参考)
- [6. 配置说明](#6-配置说明)
- [7. 完整示例](#7-完整示例)

---

## 1. 系统概述

本系统是一个基于 QLib 的量化因子研究和回测框架，主要包含两大模块：

| 模块 | 功能 | 入口 |
|------|------|------|
| **因子计算** | 计算各类量化因子 | `FactorEngine` |
| **策略回测** | 基于因子的选股回测 | `BacktestEngine` |

### 系统架构

```
quantitative/
├── factor_production/     # 因子生产模块
│   ├── data/              # 数据加载层 (QLib → Polars)
│   ├── engine/            # 因子计算引擎
│   └── factors/           # 因子计算函数
├── backtest/              # 回测模块
│   ├── engine.py          # 简化版回测引擎 ★
│   ├── backtester.py      # 完整回测逻辑
│   └── weight_optimizer.py # 权重优化器
└── run_backtest.py        # 命令行入口
```

---

## 2. 快速开始

### 2.1 环境准备

```bash
cd /home/zhenhai1/quantitative
source venv/bin/activate
```

### 2.2 一行代码完成回测

```python
from backtest import backtest

# 回测低波动因子策略
result = backtest('volatility', direction='min')
```

### 2.3 命令行方式

```bash
# 计算因子
python run_backtest.py --calc volatility

# 运行回测
python run_backtest.py --factor volatility --direction min --weight equal --n 30
```

---

## 3. 因子计算

### 3.1 可用因子列表

| 因子名称 | 说明 | 所需字段 | 推荐方向 |
|----------|------|----------|----------|
| `volatility` | 历史波动率 (年化) | `$close` | min (低波动) |
| `idio_vol` | 特质波动率 (去市场因子) | `$close` | min |
| `downside_vol` | 下行波动率 | `$close` | min |
| `turnover_mean` | N日平均换手率 | `$turnover_rate_f` | min (低换手) |
| `turnover_bias` | 换手率偏离度 | `$turnover_rate_f` | - |
| `turnover_vol` | 换手率波动率 | `$turnover_rate_f` | min |
| `turnover_ratio` | 换手率比率 | `$turnover_rate_f` | - |

### 3.2 计算因子 - Python方式

```python
from factor_production import DataManager, FactorEngine
from factor_production.factors import calc_volatility

# 初始化
dm = DataManager()
engine = FactorEngine(dm, cache_dir='/home/zhenhai1/quantitative/factor_production/cache')

# 计算因子
result = engine.run(
    factor_func=calc_volatility,   # 因子计算函数
    stocks='csi1000',              # 股票池: csi1000/csi500/csi300
    start='2020-01-01',            # 开始日期
    end='2025-12-17',              # 结束日期
    fields=['$close'],             # 所需字段
    window=20                      # 滚动窗口
)
```

### 3.3 计算因子 - 命令行方式

```bash
# 计算波动率因子
python run_backtest.py --calc volatility

# 计算换手率因子
python run_backtest.py --calc turnover_mean
```

### 3.4 增量更新因子

```python
# 增量更新（只计算新增日期的数据）
result = engine.update(
    factor_func=calc_volatility,
    stocks='csi1000',
    fields=['$close'],
    end='2025-12-18',    # 更新到最新日期
    lookback=60          # 回看天数（滚动计算需要）
)
```

### 3.5 查看已计算的因子

```python
# 列出所有已保存的因子
factors = engine.list_factors()
print(factors)  # ['volatility', 'turnover_mean', ...]

# 查看因子详情
info = engine.get_factor_info('volatility')
print(info)
# {'exists': True, 'start': '2020-01-01', 'end': '2025-12-17', 'rows': 2609426, ...}
```

---

## 4. 回测运行

### 4.1 使用 BacktestEngine (推荐)

```python
from backtest import BacktestEngine

engine = BacktestEngine()

# 运行回测
result = engine.run(
    factor='volatility',      # 因子名称 (必填)
    direction='min',          # 选股方向 (必填)
    weight='equal',           # 权重方法 (可选，默认 equal)
    n_stocks=30,              # 选股数量 (可选，默认 30)
    benchmark='sh000852',     # 基准指数 (可选，默认 中证1000)
    start_date='2021-01-01',  # 回测起始日期 (可选)
    show_plot=True            # 是否显示图表 (可选)
)
```

### 4.2 参数详解

#### `direction` - 选股方向

| 值 | 说明 | 适用因子 |
|----|------|----------|
| `'min'` | 选因子值**最小**的股票 | 波动率、换手率等 (负向因子) |
| `'max'` | 选因子值**最大**的股票 | 动量、盈利等 (正向因子) |

#### `weight` - 权重方法

| 值 | 说明 | 优点 | 缺点 |
|----|------|------|------|
| `'equal'` | 等权重 | 简单、分散 | 不考虑风险 |
| `'max_sharpe'` | 最大夏普比率 | 风险收益最优 | 计算复杂、可能集中 |
| `'min_vol'` | 最小方差 | 风险最低 | 收益可能偏低 |

#### `benchmark` - 基准指数

| 代码 | 名称 |
|------|------|
| `'sh000852'` | 中证1000 (默认) |
| `'sh000300'` | 沪深300 |
| `'sh000905'` | 中证500 |
| `'sh000016'` | 上证50 |

### 4.3 快捷函数

```python
from backtest import backtest

# 一行代码完成回测
result = backtest('volatility', direction='min')

# 等同于
engine = BacktestEngine()
result = engine.run('volatility', direction='min')
```

### 4.4 命令行方式

```bash
# 基本用法
python run_backtest.py --factor volatility --direction min

# 完整参数
python run_backtest.py \
    --factor volatility \
    --direction min \
    --weight max_sharpe \
    --n 50

# 查看帮助
python run_backtest.py --help
```

### 4.5 对比不同配置

```python
engine = BacktestEngine()

# 对比 min/max 方向 和 equal/max_sharpe 权重
df = engine.compare(
    factor='volatility',
    directions=['min', 'max'],
    weights=['equal', 'max_sharpe'],
    n_stocks=30
)

print(df)
#   direction      weight  annual_return  sharpe  max_drawdown
# 0       min       equal        -0.3491  -1.02        -0.4813
# 1       min  max_sharpe        -0.2891  -0.85        -0.4213
# 2       max       equal         0.0512   0.12        -0.5521
# 3       max  max_sharpe         0.0821   0.21        -0.4912
```

---

## 5. API 参考

### 5.1 BacktestEngine

```python
class BacktestEngine:
    """简化版回测引擎"""

    def run(self,
            factor: str,                           # 因子名称
            direction: Literal['min', 'max'],      # 选股方向
            weight: str = 'equal',                 # 权重方法
            n_stocks: int = 30,                    # 选股数量
            benchmark: str = 'sh000852',           # 基准指数
            start_date: str = '2021-01-01',        # 起始日期
            show_plot: bool = True                 # 是否画图
    ) -> Dict:
        """运行回测，返回结果字典"""
        pass

    def list_factors(self) -> list:
        """列出所有可用因子"""
        pass

    def compare(self,
                factor: str,
                directions: list,
                weights: list,
                n_stocks: int = 30
    ) -> pd.DataFrame:
        """对比不同配置的回测结果"""
        pass
```

### 5.2 FactorEngine

```python
class FactorEngine:
    """因子计算引擎"""

    def run(self,
            factor_func: Callable,     # 因子计算函数
            stocks: str | List[str],   # 股票池或股票列表
            start: str,                # 开始日期
            end: str,                  # 结束日期
            fields: List[str],         # 所需字段
            factor_col: str = None,    # 因子列名
            save: bool = True,         # 是否保存
            **kwargs                   # 传给因子函数的参数
    ) -> pl.DataFrame:
        """运行因子计算"""
        pass

    def update(self, ...) -> pl.DataFrame:
        """增量更新因子"""
        pass

    def load(self, factor_name: str) -> pl.DataFrame:
        """加载已保存的因子"""
        pass

    def list_factors(self) -> List[str]:
        """列出所有已保存因子"""
        pass

    def get_factor_info(self, factor_name: str) -> dict:
        """获取因子信息"""
        pass
```

### 5.3 回测结果结构

```python
result = engine.run('volatility', direction='min')

# result 包含以下字段:
result['metrics']           # 业绩指标 (dict)
result['portfolio_values']  # 净值序列 (DataFrame)
result['trades']            # 交易记录 (DataFrame)
result['positions']         # 持仓记录 (DataFrame)

# metrics 包含:
result['metrics']['total_return']       # 累计收益率
result['metrics']['annual_return']      # 年化收益率
result['metrics']['benchmark_return']   # 基准收益率
result['metrics']['excess_return']      # 超额收益率
result['metrics']['volatility']         # 年化波动率
result['metrics']['sharpe_ratio']       # 夏普比率
result['metrics']['max_drawdown']       # 最大回撤
result['metrics']['information_ratio']  # 信息比率
result['metrics']['calmar_ratio']       # 卡玛比率
result['metrics']['win_rate']           # 胜率
```

---

## 6. 配置说明

### 6.1 默认配置

BacktestEngine 使用以下默认配置：

```python
DEFAULT_CONFIG = {
    'initial_cash': 10_000_000,        # 初始资金: 1000万
    'backtest_start_date': '2021-01-01',

    # 交易成本
    'transaction': {
        'commission_rate': 0.0003,     # 手续费: 万3
        'min_commission': 5,           # 最小手续费: 5元
        'stamp_tax': 0.001,            # 印花税: 千1 (仅卖出)
        'slippage': 0.001,             # 滑点: 千1
    },

    # 风险控制
    'risk': {
        'max_position': 0.10,          # 单只股票最大仓位: 10%
    },

    # 调仓频率
    'rebalance': {
        'freq': 'weekly'               # 周频调仓
    }
}
```

### 6.2 自定义配置

如需更详细的配置，可直接使用底层 `Backtester` 类：

```python
from backtest.backtester import Backtester
from utils.data_loader import DataLoader

config = {
    'initial_cash': 5_000_000,
    'backtest_start_date': '2022-01-01',
    'selection': {
        'method': 'top_n',
        'n_stocks': 50,
        'ascending': True
    },
    'weighting': {
        'method': 'max_sharpe',
        'lookback_days': 252,
        'max_weight': 0.05,
        'use_dynamic_rf': True     # 使用动态SHIBOR
    },
    'rebalance': {'freq': 'monthly'},  # 月频调仓
    'benchmark': {'code': 'sh000300'}  # 沪深300基准
}

data_loader = DataLoader()
backtester = Backtester(config, data_loader)
result = backtester.run('volatility', factor_data)
```

---

## 7. 完整示例

### 7.1 示例1: 低波动率策略

```python
"""
策略: 选择波动率最低的30只股票，等权持有，周频调仓
"""
from factor_production import DataManager, FactorEngine
from factor_production.factors import calc_volatility
from backtest import BacktestEngine

# Step 1: 计算波动率因子
dm = DataManager()
factor_engine = FactorEngine(dm, cache_dir='/home/zhenhai1/quantitative/factor_production/cache')

factor_engine.run(
    factor_func=calc_volatility,
    stocks='csi1000',
    start='2020-01-01',
    end='2025-12-17',
    fields=['$close'],
    window=20
)

# Step 2: 运行回测
backtest_engine = BacktestEngine()
result = backtest_engine.run(
    factor='volatility',
    direction='min',      # 选波动率最小的
    weight='equal',
    n_stocks=30
)

# Step 3: 查看结果
print(f"年化收益: {result['metrics']['annual_return']:.2%}")
print(f"夏普比率: {result['metrics']['sharpe_ratio']:.2f}")
print(f"最大回撤: {result['metrics']['max_drawdown']:.2%}")
```

### 7.2 示例2: 低换手率策略 + 最大夏普权重

```python
"""
策略: 选择换手率最低的50只股票，最大夏普比率加权
"""
from factor_production import DataManager, FactorEngine
from factor_production.factors import calc_turnover_mean
from backtest import BacktestEngine

# Step 1: 计算换手率因子
dm = DataManager()
engine = FactorEngine(dm, cache_dir='/home/zhenhai1/quantitative/factor_production/cache')

engine.run(
    factor_func=calc_turnover_mean,
    stocks='csi1000',
    start='2020-01-01',
    end='2025-12-17',
    fields=['$turnover_rate_f'],
    window=20
)

# Step 2: 运行回测
bt = BacktestEngine()
result = bt.run(
    factor='turnover_mean',
    direction='min',       # 选换手率最小的
    weight='max_sharpe',   # 最大夏普权重
    n_stocks=50
)
```

### 7.3 示例3: 策略对比

```python
"""
对比低波动 vs 高波动、等权 vs 最大夏普
"""
from backtest import BacktestEngine

engine = BacktestEngine()

# 对比不同配置
comparison = engine.compare(
    factor='volatility',
    directions=['min', 'max'],
    weights=['equal', 'max_sharpe'],
    n_stocks=30
)

print("\n=== 策略对比结果 ===")
print(comparison.to_string(index=False))
```

### 7.4 示例4: 命令行批量测试

```bash
#!/bin/bash

# 计算所有因子
for factor in volatility turnover_mean turnover_vol; do
    python run_backtest.py --calc $factor
done

# 测试不同方向
for direction in min max; do
    python run_backtest.py --factor volatility --direction $direction --n 30
done
```

---

## 附录: 常见问题

### Q1: 因子数据在哪里？

因子数据保存在 `/home/zhenhai1/quantitative/factor_production/cache/` 目录下，格式为 `{factor_name}_{start}_{end}.parquet`

### Q2: 回测结果在哪里？

回测结果保存在 `/home/zhenhai1/quantitative/backtest/results/` 目录下，包括：
- `{factor}_values_{timestamp}.csv` - 净值曲线
- `{factor}_trades_{timestamp}.csv` - 交易记录
- `{factor}_metrics_{timestamp}.csv` - 业绩指标
- `{factor}_performance_{timestamp}.png` - 净值图表

### Q3: 如何添加新因子？

1. 在 `factor_production/factors/` 目录下创建新文件
2. 定义因子计算函数，签名为 `def calc_xxx(df: pl.DataFrame, ...) -> pl.DataFrame`
3. 在 `factor_production/factors/__init__.py` 中导出
4. 更新 `run_backtest.py` 中的 `FACTOR_MAP`

### Q4: 回测跑太慢怎么办？

- 减少选股数量 (`n_stocks`)
- 使用等权 (`weight='equal'`) 代替优化权重
- 缩短回测时间范围 (`start_date`)

---

*文档更新时间: 2025-12-18*